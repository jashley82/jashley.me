[{"model": "blog.blogpost", "pk": 1, "fields": {"comments_count": 0, "keywords_string": "", "rating_count": 0, "rating_sum": 0, "rating_average": 0.0, "site": 1, "title": "Site launched", "slug": "site-launched", "_meta_title": "", "description": "Site is live with new theme and no content WOOT", "gen_description": true, "created": "2016-04-02T02:36:13.967Z", "updated": "2016-04-02T02:36:19.168Z", "status": 2, "publish_date": "2016-04-01T19:35:54Z", "expiry_date": null, "short_url": "unset", "in_sitemap": true, "content": "<p>Site is live with new theme and no content WOOT</p>", "user": 1, "allow_comments": true, "featured_image": null, "categories": [], "related_posts": []}}, {"model": "blog.blogpost", "pk": 2, "fields": {"comments_count": 0, "keywords_string": "", "rating_count": 0, "rating_sum": 0, "rating_average": 0.0, "site": 1, "title": "keep score", "slug": "keep-score", "_meta_title": "", "description": "The quiz app works, but it could be better. How much does it suck?", "gen_description": true, "created": "2016-04-08T22:13:38.564Z", "updated": "2016-04-09T16:47:22.213Z", "status": 2, "publish_date": "2016-04-08T22:13:38Z", "expiry_date": null, "short_url": "unset", "in_sitemap": false, "content": "<p>The quiz app works, but it could be better. How much does it suck?</p>\n<ul>\n<li>It doesn't keep score</li>\n<li>It doesn't keep time</li>\n<li>There is no method in the manner&nbsp;by which questions are chosen, the database call is completely random</li>\n</ul>\n<p></p>\n<p>Ok so add a Score Card model.</p>\n<pre>class ScoreCard(models.Model):<br />    question = models.ForeignKey('Question')<br />    answered_text = models.TextField()<br />    time_completed = models.CharField(max_length=255)<br />    pass_fail = models.BooleanField()<br />    user_id = models.IntegerField()</pre>\n<p>Before migrating we should backup the database... you know... just to be safe... in case something goes wrong...</p>\n<p><code>python manage.py dumpdata &gt; src/dump.json</code></p>\n<p></p>\n<p>Make migrations.</p>\n<p><code>python manage.py makemigrations</code></p>\n<p></p>\n<p>Migrate local database.</p>\n<p><code>python manage.py migrate</code></p>\n<p></p>\n<p>At this point the web container should have been rebuilt and the new migration present. So run it.</p>\n<p><code>docker-compose run web python manage.py migrate</code></p>\n<p></p>\n<p>This data model looks pretty good. So the user will render the quiz app in his browser. The render triggers a javascript timer. The user types his answer and submits the form. At this point the javascript timer will stop and will populate the completed_time form field. The form is submitted to the check_answer view. A score card model is created and it's values populated by the validated form's fields. The contents of the score card are stored in the messaging app so the user can view his progress. The view then returns a browser redirect to a new quiz question, chosen in a semi-random manner. Sounds good. Sounds really good.</p>\n<p></p>\n<p>The view.</p>\n<pre>def check_answer(request):<br />    if request.method == 'POST':<br />        form = QuizForm(request.POST)<br />        if form.is_valid():<br />            question = Question.objects.get(id=request.POST.get('question_id'))<br />            answered_text = request.POST.get('answer_text')<br />            time_completed = request.POST.get('time_completed')<br />            pass_fail = (answered_text == question.answer_set.first().answer_text)<br />            score_card = ScoreCard.objects.create(<br />                question=question,<br />                answered_text=answered_text,<br />                time_completed=time_completed,<br />                pass_fail=pass_fail,<br />                user_id=request.user.id<br />            )<br />        if answered_text = question.answer_set.first().answer_text:<br />            messages.add_message(request, messages.SUCCESS, 'Correct')<br />        else:<br />            messages.add_message(request, messages.ERROR, 'Wrong')<br />    return redirect('do_quiz')</pre>\n<p></p>\n<p>The form.</p>\n<pre>class QuizForm(forms.Form):<br />    answer_text = forms.CharField(label='Answer', max_length=255)<br />    question_id = form.IntegerField(widget=forms.HiddenInput)<br />    time_completed = forms.CharField(widget=forms.HiddenInput)</pre>\n<p></p>\n<p>The admin.</p>\n<pre>class ScoreCardInline(admin.TabularInline):\n    model = ScoreCard\n    can_delete = False\n    readonly_fields = ('answered_text', 'time_completed', 'pass_fail', 'user_id', 'created_at')\n\n\nclass QuestionAdmin(admin.ModelAdmin):\n    inlines = [AnswerInline, ScoreCardInline,]\n\n\nadmin.site.register(Question, QuestionAdmin)</pre>\n<p></p>\n<p>The template and the javascript. It is so fancy. Oh look at the shiney.</p>\n<pre>{% extends 'base.html' %}\n\n{% block main %}\n  &lt;style&gt;\n    ul.errorlist {display:none;}\n  &lt;/style&gt;\n  \n  {% if messages %}\n    &lt;ul class=\"messages\"&gt;\n      {% for message in messages %} \n      &lt;li{% if message.tags %} class=\"{{ message.tags }}\" {% endif %}&gt;{{ message }}&lt;/li&gt;\n      {% endfor %}\n    &lt;/ul&gt;\n  {% endif %}\n  \n  {% if question %}\n    &lt;p&gt;Category: {{ question.category.title }}&lt;/p&gt;\n    &lt;p&gt;Answer: {{ question.question_text }}&lt;/p&gt;\n    &lt;form id=\"quiz_form\" action=\"/quiz/check/\" method=\"post\"&gt;\n      {% csrf_token %}\n      {{ form }}\n      &lt;input type=\"submit\" value=\"Submit\" /&gt;\n    &lt;/form&gt;\n  {% else %}\n    &lt;p&gt;No content available.&lt;/p&gt;\n  {% endif %}\n\n&lt;script type=\"text/javascript\"&gt;\nvar then = $.now();\n$('#quiz_form').submit(function(event) {\n  $('#id_time_completed').val($.now()-then);\n  })\n&lt;/script&gt;\n\n{% endblock %}</pre>\n<p></p>\n<p>It's a lot better now. So is my life. I have grown so much on this journey. Thanks django and jquery.</p>", "user": 1, "allow_comments": true, "featured_image": null, "categories": [], "related_posts": []}}, {"model": "blog.blogpost", "pk": 3, "fields": {"comments_count": 0, "keywords_string": "", "rating_count": 0, "rating_sum": 0, "rating_average": 0.0, "site": 1, "title": "securing ssh and tmux", "slug": "securing-ssh-and-tmux", "_meta_title": "", "description": "\r\nrun sshd inside of a chroot\r\njail user inside tmux via match and \"command\" config directives\r\n", "gen_description": true, "created": "2016-04-04T03:06:58.086Z", "updated": "2016-04-09T18:09:42.713Z", "status": 1, "publish_date": "2016-04-03T20:05:18Z", "expiry_date": null, "short_url": "unset", "in_sitemap": true, "content": "<ul>\r\n<li>run sshd inside of a chroot</li>\r\n<li>jail user inside tmux via match and \"command\" config directives</li>\r\n</ul>", "user": 1, "allow_comments": true, "featured_image": null, "categories": [], "related_posts": []}}, {"model": "blog.blogpost", "pk": 4, "fields": {"comments_count": 0, "keywords_string": "", "rating_count": 0, "rating_sum": 0, "rating_average": 0.0, "site": 1, "title": "watching the watcher", "slug": "watching-the-watcher", "_meta_title": "", "description": "Running into odd behavior from the watcher script with regard to html files. The problem is that the build commands aren't given time to complete. Implementing&nbsp;some multithreading would be a good fix for this. Proper asynchronous code with callbacks would also be a good choice. Instead, I'll opt for the easy solution and add some time delays.", "gen_description": true, "created": "2016-04-05T01:31:53.278Z", "updated": "2016-04-09T18:10:32.682Z", "status": 2, "publish_date": "2016-04-04T18:28:54Z", "expiry_date": null, "short_url": "unset", "in_sitemap": true, "content": "<p>Running into odd behavior from the watcher script with regard to html files. The problem is that the build commands aren't given time to complete. Implementing&nbsp;some multithreading would be a good fix for this. Proper asynchronous code with callbacks would also be a good choice. Instead, I'll opt for the easy solution and add some time delays.</p>\n<p></p>\n<pre>def build_docker(): <br />    print \"[+] Building docker container @{}\".format(get_now()) <br />    NULL = open(os.devnull, 'w') <br />    for cmd in BUILDCOMMANDS: <br />        subprocess.Popen(cmd, stdout=NULL) <br />        time.sleep(1) # give time for docker commands to complete <br />    return </pre>\n<p></p>\n<p>I also cleaned up the build commands. Now only the web container gets rebuilt, and it is properly stopped and restarted.</p>\n<pre>BUILDCOMMANDS = [\n        ['docker-compose', 'stop', 'web'], \n        ['docker-compose', 'build', 'web'], \n        ['docker-compose', 'up', 'web'],\n        ]</pre>\n<p></p>\n<p>Also for shits I'll&nbsp;parse the gitignore file for ignore patterns because that seems like an intelligent thing to do.</p>\n<pre>def parse_gitignore():\n    with open('.gitignore', 'r') as gitignore:\n        print '[*] Parsing gitignore'\n        for line in gitignore.readlines():\n            IGNORE_PATTERNS.append(line.strip())</pre>\n<p></p>\n<p>Now I have achieved contentment and my life is that much more fulfiilling. The complete code can be found at&nbsp;https://github.com/jashley82/jashley.me/blob/master/watcher.py</p>\n<p></p>", "user": 1, "allow_comments": true, "featured_image": null, "categories": [], "related_posts": []}}]
