[{"model": "blog.blogpost", "pk": 3, "fields": {"comments_count": 0, "keywords_string": "", "rating_count": 0, "rating_sum": 0, "rating_average": 0.0, "site": 1, "title": "securing ssh", "slug": "securing-ssh", "_meta_title": "", "description": "\r\nrun sshd inside of a chroot\r\njail user inside tmux via match and \"command\" config directives\r\n", "gen_description": true, "created": "2016-04-04T03:06:58.086Z", "updated": "2016-04-04T03:07:40.653Z", "status": 2, "publish_date": "2016-04-03T20:05:18Z", "expiry_date": null, "short_url": "unset", "in_sitemap": true, "content": "<ul>\r\n<li>run sshd inside of a chroot</li>\r\n<li>jail user inside tmux via match and \"command\" config directives</li>\r\n</ul>", "user": 1, "allow_comments": true, "featured_image": null, "categories": [], "related_posts": []}}, {"model": "blog.blogpost", "pk": 4, "fields": {"comments_count": 0, "keywords_string": "", "rating_count": 0, "rating_sum": 0, "rating_average": 0.0, "site": 1, "title": "watching the watcher", "slug": "watching-the-watcher", "_meta_title": "", "description": "Running into odd behavior from the watcher with regard to html files. The problem is that the build commands aren't given time to complete. Implementing&nbsp;some multithreading would be a good fix for this. Proper asynchronous code with callbacks would also be a good choice. Instead, I'll opt for the easy solution and add some time delays.", "gen_description": true, "created": "2016-04-05T01:31:53.278Z", "updated": "2016-04-05T16:26:24.949Z", "status": 2, "publish_date": "2016-04-04T18:28:54Z", "expiry_date": null, "short_url": "unset", "in_sitemap": true, "content": "<p>Running into odd behavior from the watcher with regard to html files. The problem is that the build commands aren't given time to complete. Implementing&nbsp;some multithreading would be a good fix for this. Proper asynchronous code with callbacks would also be a good choice. Instead, I'll opt for the easy solution and add some time delays.</p>\r\n<p></p>\r\n<pre>def build_docker(): <br />    print \"[+] Building docker container @{}\".format(get_now()) <br />    NULL = open(os.devnull, 'w') <br />    for cmd in BUILDCOMMANDS: <br />        subprocess.Popen(cmd, stdout=NULL) <br />        time.sleep(1) # give time for docker commands to complete <br />    return </pre>\r\n<p></p>\r\n<p>I also cleaned up the build commands. Now only the web container gets rebuilt, and it is properly stopped and restarted.</p>\r\n<pre>BUILDCOMMANDS = [\r\n        ['docker-compose', 'stop', 'web'], \r\n        ['docker-compose', 'build', 'web'], \r\n        ['docker-compose', 'up', 'web'],\r\n        ]</pre>\r\n<p></p>\r\n<p>Also for shits I'll&nbsp;parse the gitignore file for ignore patterns because that seems like an intelligent thing to do.</p>\r\n<pre>def parse_gitignore():\r\n    with open('.gitignore', 'r') as gitignore:\r\n        print '[*] Parsing gitignore'\r\n        for line in gitignore.readlines():\r\n            IGNORE_PATTERNS.append(line.strip())</pre>\r\n<p></p>\r\n<p>Now I have achieved contentment and my life is that much more fulfiilling. The complete code can be found at&nbsp;https://github.com/jashley82/jashley.me/blob/master/watcher.py</p>\r\n<p></p>", "user": 1, "allow_comments": true, "featured_image": null, "categories": [], "related_posts": []}}]
