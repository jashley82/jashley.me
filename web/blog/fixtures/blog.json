[{"model": "blog.blogpost", "pk": 1, "fields": {"comments_count": 0, "keywords_string": "", "rating_count": 0, "rating_sum": 0, "rating_average": 0.0, "site": 1, "title": "Site launched", "slug": "site-launched", "_meta_title": "", "description": "Site is live with new theme and no content WOOT", "gen_description": true, "created": "2016-04-02T02:36:13.967Z", "updated": "2016-04-02T02:36:19.168Z", "status": 2, "publish_date": "2016-04-01T19:35:54Z", "expiry_date": null, "short_url": "unset", "in_sitemap": true, "content": "<p>Site is live with new theme and no content WOOT</p>", "user": 1, "allow_comments": true, "featured_image": null, "categories": [], "related_posts": []}}, {"model": "blog.blogpost", "pk": 2, "fields": {"comments_count": 0, "keywords_string": "", "rating_count": 0, "rating_sum": 0, "rating_average": 0.0, "site": 1, "title": "keep score", "slug": "keep-score", "_meta_title": "", "description": "The quiz app works, but it could be better. How much does it suck?", "gen_description": true, "created": "2016-04-08T22:13:38.564Z", "updated": "2016-04-09T16:47:22.213Z", "status": 2, "publish_date": "2016-04-08T22:13:38Z", "expiry_date": null, "short_url": "unset", "in_sitemap": false, "content": "<p>The quiz app works, but it could be better. How much does it suck?</p>\n<ul>\n<li>It doesn't keep score</li>\n<li>It doesn't keep time</li>\n<li>There is no method in the manner&nbsp;by which questions are chosen, the database call is completely random</li>\n</ul>\n<p></p>\n<p>Ok so add a Score Card model.</p>\n<pre>class ScoreCard(models.Model):<br />    question = models.ForeignKey('Question')<br />    answered_text = models.TextField()<br />    time_completed = models.CharField(max_length=255)<br />    pass_fail = models.BooleanField()<br />    user_id = models.IntegerField()</pre>\n<p>Before migrating we should backup the database... you know... just to be safe... in case something goes wrong...</p>\n<p><code>python manage.py dumpdata &gt; src/dump.json</code></p>\n<p></p>\n<p>Make migrations.</p>\n<p><code>python manage.py makemigrations</code></p>\n<p></p>\n<p>Migrate local database.</p>\n<p><code>python manage.py migrate</code></p>\n<p></p>\n<p>At this point the web container should have been rebuilt and the new migration present. So run it.</p>\n<p><code>docker-compose run web python manage.py migrate</code></p>\n<p></p>\n<p>This data model looks pretty good. So the user will render the quiz app in his browser. The render triggers a javascript timer. The user types his answer and submits the form. At this point the javascript timer will stop and will populate the completed_time form field. The form is submitted to the check_answer view. A score card model is created and it's values populated by the validated form's fields. The contents of the score card are stored in the messaging app so the user can view his progress. The view then returns a browser redirect to a new quiz question, chosen in a semi-random manner. Sounds good. Sounds really good.</p>\n<p></p>\n<p>The view.</p>\n<pre>def check_answer(request):<br />    if request.method == 'POST':<br />        form = QuizForm(request.POST)<br />        if form.is_valid():<br />            question = Question.objects.get(id=request.POST.get('question_id'))<br />            answered_text = request.POST.get('answer_text')<br />            time_completed = request.POST.get('time_completed')<br />            pass_fail = (answered_text == question.answer_set.first().answer_text)<br />            score_card = ScoreCard.objects.create(<br />                question=question,<br />                answered_text=answered_text,<br />                time_completed=time_completed,<br />                pass_fail=pass_fail,<br />                user_id=request.user.id<br />            )<br />        if answered_text = question.answer_set.first().answer_text:<br />            messages.add_message(request, messages.SUCCESS, 'Correct')<br />        else:<br />            messages.add_message(request, messages.ERROR, 'Wrong')<br />    return redirect('do_quiz')</pre>\n<p></p>\n<p>The form.</p>\n<pre>class QuizForm(forms.Form):<br />    answer_text = forms.CharField(label='Answer', max_length=255)<br />    question_id = form.IntegerField(widget=forms.HiddenInput)<br />    time_completed = forms.CharField(widget=forms.HiddenInput)</pre>\n<p></p>\n<p>The admin.</p>\n<pre>class ScoreCardInline(admin.TabularInline):\n    model = ScoreCard\n    can_delete = False\n    readonly_fields = ('answered_text', 'time_completed', 'pass_fail', 'user_id', 'created_at')\n\n\nclass QuestionAdmin(admin.ModelAdmin):\n    inlines = [AnswerInline, ScoreCardInline,]\n\n\nadmin.site.register(Question, QuestionAdmin)</pre>\n<p></p>\n<p>The template and the javascript. It is so fancy. Oh look at the shiney.</p>\n<pre>{% extends 'base.html' %}\n\n{% block main %}\n  &lt;style&gt;\n    ul.errorlist {display:none;}\n  &lt;/style&gt;\n  \n  {% if messages %}\n    &lt;ul class=\"messages\"&gt;\n      {% for message in messages %} \n      &lt;li{% if message.tags %} class=\"{{ message.tags }}\" {% endif %}&gt;{{ message }}&lt;/li&gt;\n      {% endfor %}\n    &lt;/ul&gt;\n  {% endif %}\n  \n  {% if question %}\n    &lt;p&gt;Category: {{ question.category.title }}&lt;/p&gt;\n    &lt;p&gt;Answer: {{ question.question_text }}&lt;/p&gt;\n    &lt;form id=\"quiz_form\" action=\"/quiz/check/\" method=\"post\"&gt;\n      {% csrf_token %}\n      {{ form }}\n      &lt;input type=\"submit\" value=\"Submit\" /&gt;\n    &lt;/form&gt;\n  {% else %}\n    &lt;p&gt;No content available.&lt;/p&gt;\n  {% endif %}\n\n&lt;script type=\"text/javascript\"&gt;\nvar then = $.now();\n$('#quiz_form').submit(function(event) {\n  $('#id_time_completed').val($.now()-then);\n  })\n&lt;/script&gt;\n\n{% endblock %}</pre>\n<p></p>\n<p>It's a lot better now. So is my life. I have grown so much on this journey. Thanks django and jquery.</p>", "user": 1, "allow_comments": true, "featured_image": null, "categories": [], "related_posts": []}}, {"model": "blog.blogpost", "pk": 3, "fields": {"comments_count": 0, "keywords_string": "", "rating_count": 0, "rating_sum": 0, "rating_average": 0.0, "site": 1, "title": "securing ssh and tmux", "slug": "securing-ssh-and-tmux", "_meta_title": "", "description": "\r\nrun sshd inside of a chroot\r\njail user inside tmux via match and \"command\" config directives\r\n", "gen_description": true, "created": "2016-04-04T03:06:58.086Z", "updated": "2016-04-09T18:09:42.713Z", "status": 1, "publish_date": "2016-04-03T20:05:18Z", "expiry_date": null, "short_url": "unset", "in_sitemap": true, "content": "<ul>\r\n<li>run sshd inside of a chroot</li>\r\n<li>jail user inside tmux via match and \"command\" config directives</li>\r\n</ul>", "user": 1, "allow_comments": true, "featured_image": null, "categories": [], "related_posts": []}}, {"model": "blog.blogpost", "pk": 4, "fields": {"comments_count": 0, "keywords_string": "", "rating_count": 0, "rating_sum": 0, "rating_average": 0.0, "site": 1, "title": "watching the watcher", "slug": "watching-the-watcher", "_meta_title": "", "description": "Running into odd behavior from the watcher script with regard to html files. The problem is that the build commands aren't given time to complete. Implementing&nbsp;some multithreading would be a good fix for this. Proper asynchronous code with callbacks would also be a good choice. Instead, I'll opt for the easy solution and add some time delays.", "gen_description": true, "created": "2016-04-05T01:31:53.278Z", "updated": "2016-04-09T18:10:32.682Z", "status": 2, "publish_date": "2016-04-04T18:28:54Z", "expiry_date": null, "short_url": "unset", "in_sitemap": true, "content": "<p>Running into odd behavior from the watcher script with regard to html files. The problem is that the build commands aren't given time to complete. Implementing&nbsp;some multithreading would be a good fix for this. Proper asynchronous code with callbacks would also be a good choice. Instead, I'll opt for the easy solution and add some time delays.</p>\n<p></p>\n<pre>def build_docker(): <br />    print \"[+] Building docker container @{}\".format(get_now()) <br />    NULL = open(os.devnull, 'w') <br />    for cmd in BUILDCOMMANDS: <br />        subprocess.Popen(cmd, stdout=NULL) <br />        time.sleep(1) # give time for docker commands to complete <br />    return </pre>\n<p></p>\n<p>I also cleaned up the build commands. Now only the web container gets rebuilt, and it is properly stopped and restarted.</p>\n<pre>BUILDCOMMANDS = [\n        ['docker-compose', 'stop', 'web'], \n        ['docker-compose', 'build', 'web'], \n        ['docker-compose', 'up', 'web'],\n        ]</pre>\n<p></p>\n<p>Also for shits I'll&nbsp;parse the gitignore file for ignore patterns because that seems like an intelligent thing to do.</p>\n<pre>def parse_gitignore():\n    with open('.gitignore', 'r') as gitignore:\n        print '[*] Parsing gitignore'\n        for line in gitignore.readlines():\n            IGNORE_PATTERNS.append(line.strip())</pre>\n<p></p>\n<p>Now I have achieved contentment and my life is that much more fulfiilling. The complete code can be found at&nbsp;https://github.com/jashley82/jashley.me/blob/master/watcher.py</p>\n<p></p>", "user": 1, "allow_comments": true, "featured_image": null, "categories": [], "related_posts": []}}, {"model": "blog.blogpost", "pk": 6, "fields": {"comments_count": 0, "keywords_string": "", "rating_count": 0, "rating_sum": 0, "rating_average": 0.0, "site": 1, "title": "categories", "slug": "categories", "_meta_title": "", "description": "The quiz app still sucks. It queries a random question from the database with each request. There is no intelligence whatsoever.", "gen_description": true, "created": "2016-04-12T22:01:51.935Z", "updated": "2016-04-15T21:33:24.341Z", "status": 2, "publish_date": "2016-04-12T13:05:32Z", "expiry_date": null, "short_url": "unset", "in_sitemap": true, "content": "<p>The quiz app still sucks. It queries a random question from the database with each request. There is no intelligence whatsoever.</p>\n<p></p>\n<p>It would be better if a set of questions was presented for each category. So the user selects a category and is presented with a set of questions in random order.</p>\n<p></p>\n<p>I need some sort of intermediate view to manage the entire set of questions, and another view to present each question individually.</p>\n<p>- or-</p>\n<p>A better solution would be to store the question set in redis. &lt;&lt;&lt;&nbsp;<strong>EUREKA!</strong></p>\n<p><span style=\"text-decoration: underline;\"></span></p>\n<p><span style=\"text-decoration: underline;\">Spec.</span></p>\n<ul>\n<li>Main view displays list of categories for the user</li>\n<li>User makes a selection and is redirected to an intermediate view which retrieves question set from database and stores in redis-queue</li>\n<li>User is redirected to do_quiz view. A random question is chosen from the queue and presented to the user.</li>\n<li>If the queue is empty, the user is redirected to a summary page.</li>\n<li>User submits and is redirected back to do_quiz and presented with the next random question in the queue</li>\n</ul>\n<p>With this solution there are 4 views: category_view, intermediate_view, do_quiz view, and summary view. &nbsp;A redis backend also needs to be configured.</p>\n<p></p>\n<p>Configure the redis addon for heroku and locally with docker</p>\n<p><code>heroku addons:create redis</code></p>\n<p></p>\n<p>In docker-compose.yml, add the redis url to the web environment, add a link to the redis image, and finally add the redis image itself</p>\n<pre>&lt;&lt;&lt;&lt; docker-compose.yml&gt;&gt;&gt;&gt;&gt;</pre>\n<p></p>\n<p>At the point the watcher script should have rebuilt the web image. If not then go ahead and do it manually</p>\n<p><code>docker-compose build web</code></p>\n<p></p>\n<p>Install the django-rq addon and update requirements.txt</p>\n<p><code>pip install django-rq</code></p>\n<p></p>\n<p>Configure django-rq settings and urls</p>\n<pre>settings.py</pre>\n<p></p>\n<pre>url.py</pre>\n<p></p>\n<p>The category model is simple</p>\n<pre>&lt;&lt;&lt;models.py&gt;&gt;&gt;</pre>\n<p></p>\n<p>The views are where the business happens.</p>\n<pre>&lt;&lt;views.py&gt;&gt;</pre>\n<p></p>\n<p>Each scorecard is tied to a question via foreign key. A result model could be implemented, tying each scorecard to it's parent quiz instance.</p>\n<p></p>\n<p></p>", "user": 1, "allow_comments": true, "featured_image": null, "categories": [], "related_posts": []}}, {"model": "blog.blogpost", "pk": 10, "fields": {"comments_count": 0, "keywords_string": "", "rating_count": 0, "rating_sum": 0, "rating_average": 0.0, "site": 1, "title": "hacking on hamachi", "slug": "hacking-on-hamachi", "_meta_title": "", "description": "I am working with a Raspberry Pi, a NAS, and a Hamachi network. The goal is to share the NAS over the Hamachi network, but how can this be accomplished without root on the NAS? The solution&nbsp;is to create a samba share on the Pi, mount the NAS share under it, and finally route it all over Hamachi. Basically the Pi acts as a man in the middle between the NAS and any client on the Hamachi network.", "gen_description": true, "created": "2016-05-03T06:11:30.287Z", "updated": "2016-05-03T07:30:46.731Z", "status": 2, "publish_date": "2016-05-03T06:11:30Z", "expiry_date": null, "short_url": "unset", "in_sitemap": false, "content": "<p>I am working with a Raspberry Pi, a NAS, and a Hamachi network. The goal is to share the NAS over the Hamachi network, but how can this be accomplished without root on the NAS? The solution&nbsp;is to create a samba share on the Pi, mount the NAS share under it, and finally route it all over Hamachi. Basically the Pi acts as a man in the middle between the NAS and any client on the Hamachi network.</p>\n<p></p>\n<p>The first step is to install Hamachi on the Pi. It requires the lsb package.</p>\n<p><code>sudo apt-get update &amp;&amp; sudo apt-get -y upgrade &amp;&amp; sudo apt-get -y install lsb</code></p>\n<p></p>\n<p>Download and install the Hamachi tarball for linux.</p>\n<p><code>wget&nbsp;<a href=\"https://secure.logmein.com/labs/logmein-hamachi-2.1.0.139-armhf.tgz\">https://secure.logmein.com/labs/logmein-hamachi-2.1.0.139-armhf.tgz</a>&nbsp;</code></p>\n<p><code>tar zxvf&nbsp;<a href=\"https://secure.logmein.com/labs/logmein-hamachi-2.1.0.139-armhf.tgz\">logmein-hamachi-2.1.0.139-armhf.tgz</a>&nbsp;</code></p>\n<p><code>cd&nbsp;<a href=\"https://secure.logmein.com/labs/logmein-hamachi-2.1.0.139-armhf.tgz\">logmein-hamachi-2.1.0.139</a></code></p>\n<p><code>sudo sh install.sh</code></p>\n<p></p>\n<p>Hamachi can be configured from the command line.</p>\n<p><code>hamachi login</code></p>\n<p><code>hamachi attach &lt;<a href=\"mailto:email@address.com\">email@address.com</a>&gt;</code></p>\n<p><code>hamachi setnick &lt;nickname&gt;</code></p>\n<p><code>hamachi do-join &lt;network&gt;</code></p>\n<p></p>\n<p>With Hamachi install we need to configure Samba.</p>\n<p><code>sudo apt-get install samba samba-common-bin</code></p>\n<p></p>\n<p>Configure <code>/etc/samba/smb.conf</code>. She seems a bit bloated, but gets the job done.</p>\n<pre>[Storage]\n    path = /home/pi/smb\n    valid users = josh\n    read only = no\n    writable = yes\n    browsable = yes\n    public = no\n    write list = josh\n    create mask = 664\n    force create mode = 664\n    security mask = 664\n    force security mode = 664\n    directory mask = 2775\n    force directory mode = 2775\n    directory security mask = 2775\n    force directory security mode = 2775</pre>\n<p></p>\n<p>Samba uses a separate password database, so configure that.</p>\n<p><code>sudo smbpasswd -a josh</code></p>\n<p></p>\n<p>At this point we have a working Samba share (don't believe me, try it!) and a Hamachi network. Now we need to mount the NAS share under <code>/home/pi/smb</code> and it should be accessible to the Hamachi network, allegedly. So here is the entry to <code>/etc/fstab</code>. For some reason, even with all of these options set, the share gets mounted as a read only share. I wouldn't mind tinkering with this more to get it to work properly.</p>\n<pre>//192.168.1.102/movies /home/pi/smb cifs  credentials=/home/pi/x,rw,dir_mode=0777,file_mode=0666,uid=1000,gid=1000,noperm 0 0</pre>\n<p></p>", "user": 1, "allow_comments": true, "featured_image": null, "categories": [], "related_posts": []}}]
