/app/.heroku/python/lib/python2.7/site-packages/mezzanine/utils/conf.py:47: UserWarning: You haven't defined the ALLOWED_HOSTS settings, which Django requires. Will fall back to the domains configured as sites.
  warn("You haven't defined the ALLOWED_HOSTS settings, which "
/app/.heroku/python/lib/python2.7/site-packages/uuidfield/fields.py:38: RemovedInDjango110Warning: SubfieldBase has been deprecated. Use Field.from_db_value instead.
  class UUIDField(Field):

[{"model": "blog.blogpost", "pk": 1, "fields": {"comments_count": 0, "keywords_string": "", "rating_count": 0, "rating_sum": 0, "rating_average": 0.0, "site": 1, "title": "Site launched", "slug": "site-launched", "_meta_title": "", "description": "Site is live with new theme and no content WOOT", "gen_description": true, "created": "2016-04-02T02:36:13.967Z", "updated": "2016-04-02T02:36:19.168Z", "status": 2, "publish_date": "2016-04-01T19:35:54Z", "expiry_date": null, "short_url": "unset", "in_sitemap": true, "content": "<p>Site is live with new theme and no content WOOT</p>", "user": 1, "allow_comments": true, "featured_image": null, "categories": [], "related_posts": []}}, {"model": "blog.blogpost", "pk": 2, "fields": {"comments_count": 0, "keywords_string": "", "rating_count": 0, "rating_sum": 0, "rating_average": 0.0, "site": 1, "title": "keep score", "slug": "keep-score", "_meta_title": "", "description": "The quiz app works, but it could be better. How much does it suck?", "gen_description": true, "created": "2016-04-08T22:13:38.564Z", "updated": "2016-04-09T16:47:22.213Z", "status": 2, "publish_date": "2016-04-08T22:13:38Z", "expiry_date": null, "short_url": "unset", "in_sitemap": false, "content": "<p>The quiz app works, but it could be better. How much does it suck?</p>\n<ul>\n<li>It doesn't keep score</li>\n<li>It doesn't keep time</li>\n<li>There is no method in the manner&nbsp;by which questions are chosen, the database call is completely random</li>\n</ul>\n<p></p>\n<p>Ok so add a Score Card model.</p>\n<pre>class ScoreCard(models.Model):<br />    question = models.ForeignKey('Question')<br />    answered_text = models.TextField()<br />    time_completed = models.CharField(max_length=255)<br />    pass_fail = models.BooleanField()<br />    user_id = models.IntegerField()</pre>\n<p>Before migrating we should backup the database... you know... just to be safe... in case something goes wrong...</p>\n<p><code>python manage.py dumpdata &gt; src/dump.json</code></p>\n<p></p>\n<p>Make migrations.</p>\n<p><code>python manage.py makemigrations</code></p>\n<p></p>\n<p>Migrate local database.</p>\n<p><code>python manage.py migrate</code></p>\n<p></p>\n<p>At this point the web container should have been rebuilt and the new migration present. So run it.</p>\n<p><code>docker-compose run web python manage.py migrate</code></p>\n<p></p>\n<p>This data model looks pretty good. So the user will render the quiz app in his browser. The render triggers a javascript timer. The user types his answer and submits the form. At this point the javascript timer will stop and will populate the completed_time form field. The form is submitted to the check_answer view. A score card model is created and it's values populated by the validated form's fields. The contents of the score card are stored in the messaging app so the user can view his progress. The view then returns a browser redirect to a new quiz question, chosen in a semi-random manner. Sounds good. Sounds really good.</p>\n<p></p>\n<p>The view.</p>\n<pre>def check_answer(request):<br />    if request.method == 'POST':<br />        form = QuizForm(request.POST)<br />        if form.is_valid():<br />            question = Question.objects.get(id=request.POST.get('question_id'))<br />            answered_text = request.POST.get('answer_text')<br />            time_completed = request.POST.get('time_completed')<br />            pass_fail = (answered_text == question.answer_set.first().answer_text)<br />            score_card = ScoreCard.objects.create(<br />                question=question,<br />                answered_text=answered_text,<br />                time_completed=time_completed,<br />                pass_fail=pass_fail,<br />                user_id=request.user.id<br />            )<br />        if answered_text = question.answer_set.first().answer_text:<br />            messages.add_message(request, messages.SUCCESS, 'Correct')<br />        else:<br />            messages.add_message(request, messages.ERROR, 'Wrong')<br />    return redirect('do_quiz')</pre>\n<p></p>\n<p>The form.</p>\n<pre>class QuizForm(forms.Form):<br />    answer_text = forms.CharField(label='Answer', max_length=255)<br />    question_id = form.IntegerField(widget=forms.HiddenInput)<br />    time_completed = forms.CharField(widget=forms.HiddenInput)</pre>\n<p></p>\n<p>The admin.</p>\n<pre>class ScoreCardInline(admin.TabularInline):\n    model = ScoreCard\n    can_delete = False\n    readonly_fields = ('answered_text', 'time_completed', 'pass_fail', 'user_id', 'created_at')\n\n\nclass QuestionAdmin(admin.ModelAdmin):\n    inlines = [AnswerInline, ScoreCardInline,]\n\n\nadmin.site.register(Question, QuestionAdmin)</pre>\n<p></p>\n<p>The template and the javascript. It is so fancy. Oh look at the shiney.</p>\n<pre>{% extends 'base.html' %}\n\n{% block main %}\n  &lt;style&gt;\n    ul.errorlist {display:none;}\n  &lt;/style&gt;\n  \n  {% if messages %}\n    &lt;ul class=\"messages\"&gt;\n      {% for message in messages %} \n      &lt;li{% if message.tags %} class=\"{{ message.tags }}\" {% endif %}&gt;{{ message }}&lt;/li&gt;\n      {% endfor %}\n    &lt;/ul&gt;\n  {% endif %}\n  \n  {% if question %}\n    &lt;p&gt;Category: {{ question.category.title }}&lt;/p&gt;\n    &lt;p&gt;Answer: {{ question.question_text }}&lt;/p&gt;\n    &lt;form id=\"quiz_form\" action=\"/quiz/check/\" method=\"post\"&gt;\n      {% csrf_token %}\n      {{ form }}\n      &lt;input type=\"submit\" value=\"Submit\" /&gt;\n    &lt;/form&gt;\n  {% else %}\n    &lt;p&gt;No content available.&lt;/p&gt;\n  {% endif %}\n\n&lt;script type=\"text/javascript\"&gt;\nvar then = $.now();\n$('#quiz_form').submit(function(event) {\n  $('#id_time_completed').val($.now()-then);\n  })\n&lt;/script&gt;\n\n{% endblock %}</pre>\n<p></p>\n<p>It's a lot better now. So is my life. I have grown so much on this journey. Thanks django and jquery.</p>", "user": 1, "allow_comments": true, "featured_image": null, "categories": [], "related_posts": []}}, {"model": "blog.blogpost", "pk": 3, "fields": {"comments_count": 0, "keywords_string": "", "rating_count": 0, "rating_sum": 0, "rating_average": 0.0, "site": 1, "title": "securing ssh and tmux", "slug": "securing-ssh-and-tmux", "_meta_title": "", "description": "\r\nrun sshd inside of a chroot\r\njail user inside tmux via match and \"command\" config directives\r\n", "gen_description": true, "created": "2016-04-04T03:06:58.086Z", "updated": "2016-04-09T18:09:42.713Z", "status": 1, "publish_date": "2016-04-03T20:05:18Z", "expiry_date": null, "short_url": "unset", "in_sitemap": true, "content": "<ul>\r\n<li>run sshd inside of a chroot</li>\r\n<li>jail user inside tmux via match and \"command\" config directives</li>\r\n</ul>", "user": 1, "allow_comments": true, "featured_image": null, "categories": [], "related_posts": []}}, {"model": "blog.blogpost", "pk": 4, "fields": {"comments_count": 0, "keywords_string": "", "rating_count": 0, "rating_sum": 0, "rating_average": 0.0, "site": 1, "title": "watching the watcher", "slug": "watching-the-watcher", "_meta_title": "", "description": "Running into odd behavior from the watcher script with regard to html files. The problem is that the build commands aren't given time to complete. Implementing&nbsp;some multithreading would be a good fix for this. Proper asynchronous code with callbacks would also be a good choice. Instead, I'll opt for the easy solution and add some time delays.", "gen_description": true, "created": "2016-04-05T01:31:53.278Z", "updated": "2016-04-09T18:10:32.682Z", "status": 2, "publish_date": "2016-04-04T18:28:54Z", "expiry_date": null, "short_url": "unset", "in_sitemap": true, "content": "<p>Running into odd behavior from the watcher script with regard to html files. The problem is that the build commands aren't given time to complete. Implementing&nbsp;some multithreading would be a good fix for this. Proper asynchronous code with callbacks would also be a good choice. Instead, I'll opt for the easy solution and add some time delays.</p>\n<p></p>\n<pre>def build_docker(): <br />    print \"[+] Building docker container @{}\".format(get_now()) <br />    NULL = open(os.devnull, 'w') <br />    for cmd in BUILDCOMMANDS: <br />        subprocess.Popen(cmd, stdout=NULL) <br />        time.sleep(1) # give time for docker commands to complete <br />    return </pre>\n<p></p>\n<p>I also cleaned up the build commands. Now only the web container gets rebuilt, and it is properly stopped and restarted.</p>\n<pre>BUILDCOMMANDS = [\n        ['docker-compose', 'stop', 'web'], \n        ['docker-compose', 'build', 'web'], \n        ['docker-compose', 'up', 'web'],\n        ]</pre>\n<p></p>\n<p>Also for shits I'll&nbsp;parse the gitignore file for ignore patterns because that seems like an intelligent thing to do.</p>\n<pre>def parse_gitignore():\n    with open('.gitignore', 'r') as gitignore:\n        print '[*] Parsing gitignore'\n        for line in gitignore.readlines():\n            IGNORE_PATTERNS.append(line.strip())</pre>\n<p></p>\n<p>Now I have achieved contentment and my life is that much more fulfiilling. The complete code can be found at&nbsp;https://github.com/jashley82/jashley.me/blob/master/watcher.py</p>\n<p></p>", "user": 1, "allow_comments": true, "featured_image": null, "categories": [], "related_posts": []}}, {"model": "blog.blogpost", "pk": 6, "fields": {"comments_count": 0, "keywords_string": "", "rating_count": 0, "rating_sum": 0, "rating_average": 0.0, "site": 1, "title": "categories", "slug": "categories", "_meta_title": "", "description": "The quiz app still sucks. It queries a random question from the database with each request. There is no intelligence whatsoever.", "gen_description": true, "created": "2016-04-12T22:01:51.935Z", "updated": "2016-04-15T21:33:24.341Z", "status": 2, "publish_date": "2016-04-12T13:05:32Z", "expiry_date": null, "short_url": "unset", "in_sitemap": true, "content": "<p>The quiz app still sucks. It queries a random question from the database with each request. There is no intelligence whatsoever.</p>\n<p></p>\n<p>It would be better if a set of questions was presented for each category. So the user selects a category and is presented with a set of questions in random order.</p>\n<p></p>\n<p>I need some sort of intermediate view to manage the entire set of questions, and another view to present each question individually.</p>\n<p>- or-</p>\n<p>A better solution would be to store the question set in redis. &lt;&lt;&lt;&nbsp;<strong>EUREKA!</strong></p>\n<p><span style=\"text-decoration: underline;\"></span></p>\n<p><span style=\"text-decoration: underline;\">Spec.</span></p>\n<ul>\n<li>Main view displays list of categories for the user</li>\n<li>User makes a selection and is redirected to an intermediate view which retrieves question set from database and stores in redis-queue</li>\n<li>User is redirected to do_quiz view. A random question is chosen from the queue and presented to the user.</li>\n<li>If the queue is empty, the user is redirected to a summary page.</li>\n<li>User submits and is redirected back to do_quiz and presented with the next random question in the queue</li>\n</ul>\n<p>With this solution there are 4 views: category_view, intermediate_view, do_quiz view, and summary view. &nbsp;A redis backend also needs to be configured.</p>\n<p></p>\n<p>Configure the redis addon for heroku and locally with docker</p>\n<p><code>heroku addons:create redis</code></p>\n<p></p>\n<p>In docker-compose.yml, add the redis url to the web environment, add a link to the redis image, and finally add the redis image itself</p>\n<pre>&lt;&lt;&lt;&lt; docker-compose.yml&gt;&gt;&gt;&gt;&gt;</pre>\n<p></p>\n<p>At the point the watcher script should have rebuilt the web image. If not then go ahead and do it manually</p>\n<p><code>docker-compose build web</code></p>\n<p></p>\n<p>Install the django-rq addon and update requirements.txt</p>\n<p><code>pip install django-rq</code></p>\n<p></p>\n<p>Configure django-rq settings and urls</p>\n<pre>settings.py</pre>\n<p></p>\n<pre>url.py</pre>\n<p></p>\n<p>The category model is simple</p>\n<pre>&lt;&lt;&lt;models.py&gt;&gt;&gt;</pre>\n<p></p>\n<p>The views are where the business happens.</p>\n<pre>&lt;&lt;views.py&gt;&gt;</pre>\n<p></p>\n<p>Each scorecard is tied to a question via foreign key. A result model could be implemented, tying each scorecard to it's parent quiz instance.</p>\n<p></p>\n<p></p>", "user": 1, "allow_comments": true, "featured_image": null, "categories": [], "related_posts": []}}, {"model": "blog.blogpost", "pk": 7, "fields": {"comments_count": 0, "keywords_string": "", "rating_count": 0, "rating_sum": 0, "rating_average": 0.0, "site": 1, "title": "dev blog", "slug": "dev-blog", "_meta_title": "", "description": "rollback and fix migrations ie result and scorecard model foreign key relations", "gen_description": true, "created": "2016-04-16T01:39:40.407Z", "updated": "2016-04-19T00:37:38.210Z", "status": 1, "publish_date": "2016-04-16T01:39:40Z", "expiry_date": null, "short_url": "unset", "in_sitemap": false, "content": "<p>rollback and fix migrations ie result and scorecard model foreign key relations</p>", "user": 1, "allow_comments": true, "featured_image": null, "categories": [], "related_posts": []}}, {"model": "blog.blogpost", "pk": 8, "fields": {"comments_count": 0, "keywords_string": "", "rating_count": 0, "rating_sum": 0, "rating_average": 0.0, "site": 1, "title": "cbt nuggets 02 hardware settings", "slug": "cbt-nuggets-02-hardware-settings", "_meta_title": "", "description": "", "gen_description": true, "created": "2016-04-19T20:22:58.282Z", "updated": "2016-04-19T20:22:58.282Z", "status": 1, "publish_date": "2016-04-19T20:22:58.270Z", "expiry_date": null, "short_url": null, "in_sitemap": false, "content": "<p><br></p>", "user": 1, "allow_comments": true, "featured_image": null, "categories": [], "related_posts": []}}, {"model": "blog.blogpost", "pk": 9, "fields": {"comments_count": 0, "keywords_string": "", "rating_count": 0, "rating_sum": 0, "rating_average": 0.0, "site": 1, "title": "dev blog", "slug": "dev-blog-1", "_meta_title": "", "description": "management command to:", "gen_description": true, "created": "2016-04-21T22:48:48.585Z", "updated": "2016-04-21T22:53:40.076Z", "status": 1, "publish_date": "2016-04-21T22:48:48.566Z", "expiry_date": null, "short_url": "unset", "in_sitemap": false, "content": "<p>management command to:</p>\n<ul>\n<li>iterate over a list of vocabulary words and</li>\n<li>populate question:answer sets for a category</li>\n<li>definition = question</li>\n<li>vocabulary term = answer</li>\n</ul>\n<p></p>", "user": 1, "allow_comments": true, "featured_image": null, "categories": [], "related_posts": []}}]